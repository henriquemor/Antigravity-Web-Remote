<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Remote Control</title>
    <style>
        * { box-sizing: border-box; touch-action: manipulation; }
        html, body { 
            margin: 0; padding: 0; background: #000; 
            width: 100%; height: 100%;
            overflow: hidden; position: fixed;
            user-select: none; -webkit-user-select: none;
        }
        body {
            display: flex; flex-direction: column;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: white;
        }

        /* Top Bar */
        .header {
            background: #1a1a1a; padding: 6px;
            display: flex; flex-direction: column; gap: 4px;
            z-index: 200; border-bottom: 1px solid #333;
        }

        .status-row {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 10px; font-family: monospace; color: #888;
        }

        .status-right { display: flex; align-items: center; gap: 8px; }

        .interval-links a { color: #007bff; text-decoration: none; cursor: pointer; margin-right: 5px; padding: 2px 4px; }
        .interval-links a.active { color: #0f0; font-weight: bold; }

        .controls-main { display: flex; gap: 4px; align-items: center; }

        .btn {
            background: #333; border: 1px solid #444; color: white; padding: 6px 2px;
            cursor: pointer; border-radius: 4px; font-size: 11px; text-align: center;
            flex: 0 0 50px; -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        .btn-mini {
            flex: 0 0 auto; padding: 2px 6px; font-size: 10px; width: auto; 
            background: #444; color: #ccc;
        }
        .btn.active { background: #28a745; border-color: #218838; font-weight: bold; }
        .btn-toggle-active { background: #007bff; border-color: #0056b3; }

        #btn-drag.holding { background: #dc3545; border-color: #bd2130; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }

        input[type="text"] {
            flex: 1; padding: 6px 8px; border-radius: 4px; border: 1px solid #444;
            background: #111; color: white; font-size: 14px; min-width: 0;
        }

        #btn-send { flex: 0 0 45px; background: #28a745; border-color: #218838; padding: 6px 2px; }

        .controls-extra { 
            display: none; padding: 4px 8px; gap: 4px; 
            background: #1a1a1a; border-bottom: 1px solid #333;
            flex-wrap: wrap; justify-content: center;
        }
        .controls-extra .btn { 
            flex: 1 1 40px; min-width: 40px; padding: 10px 2px;
            background: #222; font-weight: bold;
        }
        .controls-extra .btn-key { background: #444; }

        #viewport {
            flex: 1; position: relative; overflow: hidden;
            background: #000; touch-action: none;
        }

        #screen-wrapper {
            position: absolute; transform-origin: 0 0;
            display: inline-block; will-change: transform;
        }

        #screen { display: block; width: auto; height: auto; }

        .update-time { color: #0f0; }

        /* Virtual Cursor */
        #virtual-cursor {
            position: absolute;
            pointer-events: none;
            z-index: 100;
            display: none;
            transform: translate(-18.75%, -18.75%);
        }
    </style>
</head>
<body oncontextmenu="return false;">
    <div id="auth-overlay" style="position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 1000; display: none; flex-direction: column; align-items: center; justify-content: center;">
        <div style="background: #222; padding: 20px; border-radius: 8px; border: 1px solid #444; width: 280px; text-align: center;">
            <div style="font-weight:bold; margin-bottom:10px">Access Required</div>
            <input type="password" id="pin-input" placeholder="Enter PIN" style="width: 100%; padding: 10px; margin: 15px 0; background: #000; border: 1px solid #444; color: white; border-radius: 4px;">
            <button id="btn-login" style="width: 100%; padding: 10px; background: #007bff; border: none; color: white; border-radius: 4px; font-weight: bold;">Connect</button>
        </div>
    </div>

    <div class="header">
        <div class="status-row">
            <div class="interval-links" id="interval-controls">
                <a data-ms="100">100ms</a>
                <a data-ms="500" class="active">500ms</a>
                <a data-ms="1000">1s</a>
                <a data-ms="2000">2s</a>
                <a data-ms="4000">4s</a>
                <a id="link-stop">stop</a>
                <a id="link-fetch" style="display:none">fetch</a>
            </div>
            <div class="status-right">
                <span id="res-info">Loading...</span>
                <button class="btn btn-mini" id="btn-reset">res</button>
                <span id="time-ago" class="update-time">0</span>s
            </div>
        </div>
        
        <div class="controls-main">
            <button class="btn" id="btn-left">L</button>
            <button class="btn" id="btn-right">R</button>
            <button class="btn" id="btn-toggle-extra">+</button>
            <input type="text" id="text-input" placeholder="Type text...">
            <button class="btn" id="btn-send">send</button>
        </div>
        <div class="controls-extra" id="controls-extra">
            <button class="btn" id="btn-trackpad" style="flex: 0 0 100px;">Track Mode</button>
            <button class="btn" id="btn-drag" style="flex: 0 0 70px;">Drag</button>
            <button class="btn btn-key" data-key="up">↑</button>
            <button class="btn btn-key" data-key="down">↓</button>
            <button class="btn btn-key" data-key="left">←</button>
            <button class="btn btn-key" data-key="right">→</button>
            <button class="btn btn-key" data-key="enter">Ent</button>
            <button class="btn btn-key" data-key="tab">Tab</button>
            <button class="btn btn-key" data-key="escape">Esc</button>
        </div>
    </div>

    <div id="viewport">
        <div id="screen-wrapper">
            <div id="virtual-cursor">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 256 256">
                    <path fill="white" d="M195.31,208,144,156.69a16,16,0,0,0-26,4.93c0,.11-.09.22-.13.32l-17.65,46L48,48l159.85,52.2-45.95,17.64-.32.13a16,16,0,0,0-4.93,26h0L208,195.31Z"></path>
                    <path fill="black" d="M168,132.69,214.08,115l.33-.13A16,16,0,0,0,213,85.07L52.92,32.8A15.95,15.95,0,0,0,32.8,52.92L85.07,213a15.82,15.82,0,0,0,14.41,11l.78,0a15.84,15.84,0,0,0,14.61-9.59l.13-.33L132.69,168,184,219.31a16,16,0,0,0,22.63,0l12.68-12.68a16,16,0,0,0,0-22.63ZM195.31,208,144,156.69a16,16,0,0,0-26,4.93c0,.11-.09.22-.13.32l-17.65,46L48,48l159.85,52.2-45.95,17.64-.32.13a16,16,0,0,0-4.93,26h0L208,195.31Z"></path>
                </svg>
            </div>
            <img id="screen" src="" alt="Snapshot">
        </div>
    </div>

    <script>
        document.addEventListener('touchstart', (e) => { if (e.touches.length > 1) e.preventDefault(); }, {passive: false});
        document.addEventListener('gesturestart', (e) => e.preventDefault());
        document.addEventListener('dblclick', (e) => e.preventDefault());

        const img = document.getElementById('screen');
        const wrapper = document.getElementById('screen-wrapper');
        const viewport = document.getElementById('viewport');
        const resInfo = document.getElementById('res-info');
        const timeAgoLabel = document.getElementById('time-ago');
        const textInput = document.getElementById('text-input');
        const virtualCursor = document.getElementById('virtual-cursor');
        
        let screenWidth = 2560, screenHeight = 1440;
        let lastUpdateTimestamp = Date.now();
        let clickMode = 'none';
        let isTrackpad = false;
        let isDragging = false;
        let refreshInterval = 500;
        let accessToken = localStorage.getItem('remote_token') || '';
        let isStopped = false;
        let refreshTimeout = null;

        let scale = 1, posX = 0, posY = 0;
        let refScale = 1, refPosX = 0, refPosY = 0;
        let refMidpoint = { x: 0, y: 0 }, refPinchDist = 0;
        let _vLastTouch = null;

        async function checkAuth() {
            try {
                const r = await fetch('/api/auth-config');
                const config = await r.json();
                if (config.required && !accessToken) {
                    document.getElementById('auth-overlay').style.display = 'flex';
                } else { init(); }
            } catch (e) { setTimeout(checkAuth, 2000); }
        }

        const apiFetch = (url, options = {}) => {
            if (accessToken) options.headers = { ...options.headers, 'x-auth-token': accessToken };
            return fetch(url, options);
        };

        function updateTransform() {
            wrapper.style.transform = `translate3d(${posX}px, ${posY}px, 0) scale(${scale})`;
        }

        const getDist = (t1, t2) => Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);

        function getV() {
            const all = Array.from(arguments[0]);
            return all.filter(t => viewport.contains(t.target));
        }

        function syncReferences(vTouches) {
            refScale = scale; refPosX = posX; refPosY = posY;
            if (vTouches.length === 2) {
                refPinchDist = getDist(vTouches[0], vTouches[1]);
                refMidpoint = { x: (vTouches[0].clientX + vTouches[1].clientX) / 2, y: (vTouches[0].clientY + vTouches[1].clientY) / 2 };
            }
        }

        viewport.addEventListener('touchstart', (e) => {
            const v = getV(e.touches);
            if (v.length === 1) {
                const rect = img.getBoundingClientRect();
                _vLastTouch = { x: v[0].clientX, y: v[0].clientY };
                if (!isTrackpad && clickMode === 'drag') {
                    const x = (v[0].clientX - rect.left) / (rect.width / screenWidth);
                    const y = (v[0].clientY - rect.top) / (rect.height / screenHeight);
                    apiFetch('/api/click', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ x, y, button: 'left', action: 'down' }) });
                }
            }
            syncReferences(v);
        }, {passive: false});

        viewport.addEventListener('touchend', (e) => {
            const vC = getV(e.changedTouches);
            const vT = getV(e.touches);
            if (!isTrackpad && clickMode === 'drag' && vC.length === 1 && vT.length === 0) {
                const rect = img.getBoundingClientRect();
                const x = (vC[0].clientX - rect.left) / (rect.width / screenWidth);
                const y = (vC[0].clientY - rect.top) / (rect.height / screenHeight);
                apiFetch('/api/click', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ x, y, button: 'left', action: 'up' }) });
            }
            syncReferences(vT);
        }, {passive: false});

        viewport.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const v = getV(e.touches);
            if (v.length === 1) {
                const rect = img.getBoundingClientRect();
                const t = v[0];
                if (isTrackpad) {
                    if (!_vLastTouch) { _vLastTouch = { x: t.clientX, y: t.clientY }; return; }
                    const dx = (t.clientX - _vLastTouch.x) / (rect.width / screenWidth);
                    const dy = (t.clientY - _vLastTouch.y) / (rect.height / screenHeight);
                    _vLastTouch = { x: t.clientX, y: t.clientY };
                    if (Math.abs(dx) > 0.05 || Math.abs(dy) > 0.05) {
                        apiFetch('/api/mouse-delta', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ dx, dy }) });
                    }
                } else {
                    const x = (t.clientX - rect.left) / (rect.width / screenWidth);
                    const y = (t.clientY - rect.top) / (rect.height / screenHeight);
                    if (!window._lastMoveTS || Date.now() - window._lastMoveTS > 40) {
                        window._lastMoveTS = Date.now();
                        apiFetch('/api/click', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ x, y, action: 'move' }) });
                    }
                }
            } else if (v.length === 2) {
                const curM = { x: (v[0].clientX + v[1].clientX) / 2, y: (v[0].clientY + v[1].clientY) / 2 };
                const currentDist = getDist(v[0], v[1]);
                const newScale = Math.min(Math.max(refScale * (currentDist / refPinchDist), 0.02), 20);
                const ratio = newScale / refScale;
                posX = curM.x - (refMidpoint.x - refPosX) * ratio;
                posY = curM.y - (refMidpoint.y - refPosY) * ratio;
                scale = newScale;
                updateTransform();
            }
        }, {passive: false});

        const attachControl = (id, handler) => {
            const el = document.getElementById(id);
            const fn = (e) => {
                e.preventDefault(); e.stopPropagation();
                handler(e);
            };
            el.addEventListener('touchstart', fn, {passive: false}); el.addEventListener('mousedown', fn);
        };

        attachControl('btn-left', () => {
            if (isTrackpad) apiFetch('/api/mouse-click', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ button: 'left' }) });
            else setMode('left');
        });
        attachControl('btn-right', () => {
            if (isTrackpad) apiFetch('/api/mouse-click', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ button: 'right' }) });
            else setMode('right');
        });
        attachControl('btn-drag', () => {
            if (isTrackpad) {
                isDragging = !isDragging;
                document.getElementById('btn-drag').classList.toggle('holding', isDragging);
                apiFetch('/api/mouse-click', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ button: 'left', action: isDragging ? 'down' : 'up' }) });
            } else setMode('drag');
        });
        attachControl('btn-trackpad', (e) => {
            isTrackpad = !isTrackpad;
            document.getElementById('btn-trackpad').classList.toggle('btn-toggle-active', isTrackpad);
            if (isTrackpad) {
                document.querySelectorAll('.controls-main .btn').forEach(b => b.classList.remove('active'));
            } else {
                setMode('left');
                if (isDragging) {
                    isDragging = false; 
                    document.getElementById('btn-drag').classList.remove('holding');
                    apiFetch('/api/mouse-click', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ button: 'left', action: 'up' }) });
                }
            }
            syncReferences(getV(e?.touches || []));
        });

        const setMode = (m) => {
            if (isTrackpad) return;
            clickMode = (clickMode === m && (m === 'left' || m === 'right')) ? 'none' : m;
            document.querySelectorAll('.controls-main .btn').forEach(b => { if(b.id !== 'btn-send') b.classList.remove('active'); });
            const activeBtn = document.getElementById('btn-' + clickMode);
            if (activeBtn) activeBtn.classList.add('active');
        };

        const btnToggleExtra = document.getElementById('btn-toggle-extra');
        const extraLinks = document.getElementById('interval-controls');

        btnToggleExtra.onclick = (e) => {
            e.stopPropagation();
            const extra = document.getElementById('controls-extra');
            const show = extra.style.display !== 'flex';
            extra.style.display = show ? 'flex' : 'none';
            btnToggleExtra.classList.toggle('btn-toggle-active', show);
        };

        const handleIntervalClick = (target) => {
            if (target.dataset.ms) {
                isStopped = false; refreshInterval = parseInt(target.dataset.ms);
                document.querySelectorAll('#interval-controls a').forEach(a => a.classList.remove('active'));
                target.classList.add('active');
                document.getElementById('link-stop').style.display = 'inline';
                document.getElementById('link-fetch').style.display = 'none';
                refreshFrame();
            } else if (target.id === 'link-stop') {
                isStopped = true; clearTimeout(refreshTimeout);
                document.querySelectorAll('#interval-controls a').forEach(a => a.classList.remove('active'));
                target.style.display = 'none';
                document.getElementById('link-fetch').style.display = 'inline';
            } else if (target.id === 'link-fetch') {
                const n = new Image();
                n.src = `/api/screenshot?t=${Date.now()}${accessToken ? '&token='+accessToken : ''}`;
                n.onload = () => { img.src = n.src; lastUpdateTimestamp = Date.now(); updateMouse(); };
            }
        };

        extraLinks.addEventListener('touchstart', (e) => {
            if (e.target.tagName === 'A') { e.preventDefault(); e.stopPropagation(); handleIntervalClick(e.target); }
        }, {passive: false});

        document.querySelectorAll('.btn-key').forEach(btn => {
            btn.onclick = (e) => {
                e.stopPropagation();
                apiFetch('/api/key', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ key: btn.dataset.key }) });
            };
        });

        document.getElementById('btn-send').onclick = (e) => {
            e.stopPropagation();
            const t = textInput.value;
            if (!t) return;
            apiFetch('/api/type', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: t }) }).then(() => { textInput.value = ''; });
        };

        document.getElementById('btn-reset').onclick = (e) => {
            e.stopPropagation();
            scale = viewport.clientWidth / screenWidth; posX = 0; posY = 0; updateTransform();
        };

        function init() { updateInfo(); refreshFrame(); setInterval(() => { timeAgoLabel.innerText = Math.floor((Date.now() - lastUpdateTimestamp) / 1000); }, 1000); }
        async function updateInfo() {
            try {
                const r = await apiFetch('/api/info');
                const d = await r.json();
                screenWidth = d.width; screenHeight = d.height;
                resInfo.innerText = `${screenWidth}x${screenHeight}`;
                scale = viewport.clientWidth / screenWidth; updateTransform();
            } catch (e) {}
        }
        async function updateMouse() {
            if (isStopped) return;
            try {
                const r = await apiFetch('/api/mouse');
                if (r.ok) {
                    const pos = await r.json();
                    const rx = img.naturalWidth / screenWidth, ry = img.naturalHeight / screenHeight;
                    virtualCursor.style.display = 'block';
                    virtualCursor.style.left = (pos.x * rx) + 'px';
                    virtualCursor.style.top = (pos.y * ry) + 'px';
                }
            } catch (e) {}
        }
        function refreshFrame() {
            if (isStopped) return;
            const s = Date.now();
            const n = new Image();
            n.src = `/api/screenshot?t=${s}${accessToken ? '&token='+accessToken : ''}`;
            n.onload = () => {
                if (isStopped) return; img.src = n.src; lastUpdateTimestamp = Date.now(); updateMouse();
                refreshTimeout = setTimeout(refreshFrame, Math.max(50, refreshInterval - (Date.now() - s)));
            };
            n.onerror = () => { if (!isStopped) setTimeout(refreshFrame, 200); };
        }

        img.addEventListener('touchstart', (e) => { 
            const vt = getV(e.touches);
            if (!isTrackpad && vt.length === 1) { 
                window._tstart = Date.now(); window._lpos = { x: vt[0].clientX, y: vt[0].clientY }; 
            } 
        });
        img.addEventListener('touchend', (e) => {
            const vC = getV(e.changedTouches);
            const vT = getV(e.touches);
            if (isTrackpad || vC.length !== 1 || vT.length > 0 || clickMode === 'none' || clickMode === 'drag') return;
            if (Date.now() - window._tstart < 300 && Math.hypot(vC[0].clientX - window._lpos.x, vC[0].clientY - window._lpos.y) < 10) {
                const r = img.getBoundingClientRect();
                const x = (vC[0].clientX - r.left) / (r.width / screenWidth);
                const y = (vC[0].clientY - r.top) / (r.height / screenHeight);
                apiFetch('/api/click', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ x, y, button: clickMode }) });
            }
        });

        checkAuth();
    </script>
</body>
</html>
