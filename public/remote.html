<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Remote Control</title>
    <style>
        * { box-sizing: border-box; }
        body { 
            margin: 0; padding: 0; background: #000; 
            display: flex; flex-direction: column; height: 100vh; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            color: white; overflow: hidden;
        }

        /* Top Bar */
        .header {
            background: #1a1a1a; padding: 8px;
            display: flex; flex-direction: column; gap: 6px;
            z-index: 200; border-bottom: 1px solid #333;
        }

        .status-row {
            display: flex; justify-content: space-between; align-items: center;
            font-size: 10px; font-family: monospace; color: #888;
        }

        .status-right { display: flex; align-items: center; gap: 8px; }

        .interval-links a { color: #007bff; text-decoration: none; cursor: pointer; margin-right: 5px; }
        .interval-links a.active { color: #0f0; font-weight: bold; }

        .controls-main { display: flex; gap: 4px; align-items: center; }

        .btn {
            background: #333; border: 1px solid #444; color: white; padding: 8px 2px;
            cursor: pointer; border-radius: 4px; font-size: 12px; text-align: center;
            flex: 0 0 35px; -webkit-tap-highlight-color: transparent;
        }
        .btn.active { background: #28a745; border-color: #218838; font-weight: bold; }

        .btn-mini {
            padding: 2px 6px; font-size: 10px; flex: 0 0 auto; background: #444; color: #ccc;
        }

        input[type="text"] {
            flex: 1; padding: 8px; border-radius: 4px; border: 1px solid #444;
            background: #111; color: white; font-size: 14px; min-width: 0;
        }

        #btn-send { flex: 0 0 40px; background: #28a745; border-color: #218838; }

        #viewport {
            flex: 1; position: relative; overflow: hidden;
            background: #000; touch-action: none;
        }

        #screen-wrapper {
            position: absolute; transform-origin: 0 0;
            display: inline-block; will-change: transform;
        }

        #screen { display: block; width: auto; height: auto; }

        .update-time { color: #0f0; }
    </style>
</head>
<body>
    <div class="header">
        <div class="status-row">
            <div class="interval-links" id="interval-controls">
                <a data-ms="100">100ms</a>
                <a data-ms="500" class="active">500ms</a>
                <a data-ms="1000">1s</a>
                <a data-ms="2000">2s</a>
            </div>
            <div class="status-right">
                <span id="res-info">Loading...</span>
                <button class="btn btn-mini" id="btn-reset">reset</button>
                <span id="time-ago" class="update-time">0</span>s ago
            </div>
        </div>
        
        <div class="controls-main">
            <button class="btn active" id="btn-left">L</button>
            <button class="btn" id="btn-right">R</button>
            <button class="btn" id="btn-none">X</button>
            <input type="text" id="text-input" placeholder="Type text...">
            <button class="btn" id="btn-send">send</button>
        </div>
    </div>

    <div id="viewport">
        <div id="screen-wrapper">
            <img id="screen" src="" alt="Desktop Snapshot">
        </div>
    </div>

    <script>
        const img = document.getElementById('screen');
        const wrapper = document.getElementById('screen-wrapper');
        const viewport = document.getElementById('viewport');
        const resInfo = document.getElementById('res-info');
        const timeAgoLabel = document.getElementById('time-ago');
        const textInput = document.getElementById('text-input');
        
        let screenWidth = 1920, screenHeight = 1080;
        let lastUpdateTimestamp = Date.now();
        let clickMode = 'left';
        let refreshInterval = 500;
        let accessToken = localStorage.getItem('remote_token') || '';

        // --- AUTH LOGIC ---
        async function checkAuth() {
            try {
                const r = await fetch('/api/auth-config');
                const config = await r.json();
                
                if (config.required) {
                    if (!accessToken) {
                        const pin = window.prompt("Enter Access PIN:");
                        if (pin) {
                            accessToken = pin;
                            localStorage.setItem('remote_token', pin);
                            init();
                        } else {
                            // If cancelled, keep checking or show error
                            location.reload();
                        }
                    } else {
                        init();
                    }
                } else {
                    accessToken = '';
                    init();
                }
            } catch (e) { 
                console.error("Auth check failed", e); 
                // Retry in case of network glitch
                setTimeout(checkAuth, 2000);
            }
        }

        const apiFetch = (url, options = {}) => {
            if (accessToken) {
                options.headers = { ...options.headers, 'x-auth-token': accessToken };
            }
            return fetch(url, options);
        };

        // --- TRANSFORMATION LOGIC ---
        let scale = 1, posX = 0, posY = 0;
        let refScale = 1, refPosX = 0, refPosY = 0;
        let refMidpoint = { x: 0, y: 0 }, refPinchDist = 0, refSingleFinger = { x: 0, y: 0 };

        function updateTransform() {
            wrapper.style.transform = `translate3d(${posX}px, ${posY}px, 0) scale(${scale})`;
        }

        const getMidpoint = (t1, t2) => ({
            x: (t1.clientX + t2.clientX) / 2,
            y: (t1.clientY + t2.clientY) / 2
        });

        const getDist = (t1, t2) => Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);

        function syncReferences(touches) {
            refScale = scale; refPosX = posX; refPosY = posY;
            if (touches.length === 1) {
                refSingleFinger.x = touches[0].clientX; refSingleFinger.y = touches[0].clientY;
            } else if (touches.length === 2) {
                refPinchDist = getDist(touches[0], touches[1]);
                refMidpoint = getMidpoint(touches[0], touches[1]);
            }
        }

        viewport.addEventListener('touchstart', (e) => syncReferences(e.touches), {passive: false});
        viewport.addEventListener('touchend', (e) => syncReferences(e.touches), {passive: false});
        viewport.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 1) {
                posX = refPosX + (e.touches[0].clientX - refSingleFinger.x);
                posY = refPosY + (e.touches[0].clientY - refSingleFinger.y);
            } else if (e.touches.length === 2) {
                const currentDist = getDist(e.touches[0], e.touches[1]);
                const currentMidpoint = getMidpoint(e.touches[0], e.touches[1]);
                const newScale = refScale * (currentDist / refPinchDist);
                const zoomRatio = newScale / refScale;
                posX = currentMidpoint.x - (refMidpoint.x - refPosX) * zoomRatio;
                posY = currentMidpoint.y - (refMidpoint.y - refPosY) * zoomRatio;
                scale = Math.min(Math.max(newScale, 0.02), 20);
            }
            updateTransform();
        }, {passive: false});

        document.getElementById('btn-reset').onclick = () => {
            scale = viewport.clientWidth / screenWidth;
            posX = 0; posY = 0;
            updateTransform();
        };

        // --- MOUSE Support ---
        let isDragging = false;
        viewport.addEventListener('mousedown', (e) => {
            isDragging = true;
            refSingleFinger.x = e.clientX; refSingleFinger.y = e.clientY;
            refPosX = posX; refPosY = posY;
        });
        window.addEventListener('mousemove', (e) => {
            if (isDragging) {
                posX = refPosX + (e.clientX - refSingleFinger.x);
                posY = refPosY + (e.clientY - refSingleFinger.y);
                updateTransform();
            }
        });
        window.addEventListener('mouseup', () => isDragging = false);

        // --- CORE LOGIC ---
        function init() {
            updateInfo();
            refreshFrame();
        }

        async function updateInfo() {
            try {
                const r = await apiFetch('/api/info');
                if (r.status === 401) {
                    localStorage.removeItem('remote_token');
                    accessToken = '';
                    checkAuth();
                    return;
                }
                const data = await r.json();
                screenWidth = data.width; screenHeight = data.height;
                resInfo.innerText = `${screenWidth}x${screenHeight}`;
                scale = viewport.clientWidth / screenWidth;
                updateTransform();
            } catch (e) { console.error(e); }
        }

        function refreshFrame() {
            const startTime = Date.now();
            const nextFrame = new Image();
            const tokenParam = accessToken ? `&token=${accessToken}` : '';
            nextFrame.src = `/api/screenshot?t=${startTime}${tokenParam}`;
            nextFrame.onload = () => {
                img.src = nextFrame.src;
                lastUpdateTimestamp = Date.now();
                setTimeout(refreshFrame, Math.max(50, refreshInterval - (Date.now() - startTime)));
            };
            nextFrame.onerror = () => {
                // If it fails due to auth, stop refreshing and re-check auth
                setTimeout(refreshFrame, 500);
            };
        }

        setInterval(() => {
            timeAgoLabel.innerText = Math.floor((Date.now() - lastUpdateTimestamp) / 1000);
        }, 1000);

        document.getElementById('interval-controls').onclick = (e) => {
            if (e.target.tagName === 'A') {
                refreshInterval = parseInt(e.target.dataset.ms);
                document.querySelectorAll('#interval-controls a').forEach(a => a.classList.remove('active'));
                e.target.classList.add('active');
            }
        };

        const setMode = (mode) => {
            clickMode = mode;
            document.querySelectorAll('.controls-main .btn').forEach(b => {
                if(b.id !== 'btn-send') b.classList.remove('active');
            });
            document.getElementById('btn-' + mode).classList.add('active');
        };
        document.getElementById('btn-left').onclick = () => setMode('left');
        document.getElementById('btn-right').onclick = () => setMode('right');
        document.getElementById('btn-none').onclick = () => setMode('none');

        const sendText = () => {
            const text = textInput.value;
            if (!text) return;
            apiFetch('/api/type', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text })
            }).then(() => { textInput.value = ''; });
        };
        document.getElementById('btn-send').onclick = sendText;
        textInput.onkeypress = (e) => { if(e.key === 'Enter') sendText(); };

        let touchStartTS = 0;
        img.addEventListener('touchstart', () => touchStartTS = Date.now());
        img.addEventListener('click', (e) => {
            if (clickMode === 'none') return;
            if (Date.now() - touchStartTS > 250) return;
            const rect = img.getBoundingClientRect();
            const x = (e.clientX - rect.left) / (rect.width / screenWidth);
            const y = (e.clientY - rect.top) / (rect.height / screenHeight);
            apiFetch('/api/click', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ x, y, button: clickMode })
            });
        });
        img.addEventListener('contextmenu', e => e.preventDefault());

        checkAuth();
    </script>
</body>
</html>
